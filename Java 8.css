
üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†
            üÜóüÜóüÜóüÜóüÜó  JAVA 8    üÜóüÜóüÜóüÜóüÜó
üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†


Java 8, ƒë∆∞·ª£c ph√°t h√†nh v√†o th√°ng 3 nƒÉm 2014, l√† m·ªôt trong nh·ªØng phi√™n b·∫£n quan tr·ªçng nh·∫•t trong l·ªãch s·ª≠ ph√°t tri·ªÉn c·ªßa Java. gi·ªõi thi·ªáu l·∫≠p tr√¨nh h√†m (Functional Programming) v√†o Java. 

‚úÖ 1. Ph∆∞∆°ng th·ª©c m·∫∑c ƒë·ªãnh (Default method) v√† ph∆∞∆°ng th·ª©c tƒ©nh (Static method) trong interface

Kh√°i ni·ªám: Ph∆∞∆°ng th·ª©c m·∫∑c ƒë·ªãnh trong interface ƒë·ªãnh nghƒ©a 1 h√†m chung m√† khi c√°c class con k·∫ø th·ª´a qua t·ª´ kh√≥a implement KH√îNG b·∫Øt bu·ªôc ph·∫£i ghi ƒë√® l·∫°i
L√Ω do s·ª≠ d·ª•ng: 
    Duy tr√¨ kh·∫£ nƒÉng t∆∞∆°ng th√≠ch ng∆∞·ª£c khi th√™m ph∆∞∆°ng th·ª©c m·ªõi v√†o interface
    Cho ph√©p c√†i ƒë·∫∑t s·∫µn logic m√† c√°c l·ªõp c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng

    Vd:
    interface Car {
    default void start() {
        System.out.println("Starting...");
        }
    }

    class Honda implements Car {}

    public class Main {
        public static void main(String[] args) {
            Honda test = new Honda();
            test.start();
        }
    } //Starting...


 ‚úÖ 2. Ph∆∞∆°ng th·ª©c tƒ©nh (Static method)

 ƒê∆∞·ª£c ƒë·ªãnh nghƒ©a qua t·ª´ kh√≥a static. V√† CH·ªà THU·ªòC V·ªÄ  ch√≠nh Interface , kh√¥ng ph·∫£i c√°c l·ªõp con khi implement
 L√Ω do s·ª≠ d·ª•ng
    T·ªï ch·ª©c c√°c ph∆∞∆°ng th·ª©c ti·ªán √≠ch li√™n quan tr·ª±c ti·∫øp ƒë·∫øn interface
    TƒÉng t√≠nh m√¥-ƒëun v√† r√µ r√†ng trong m√£ ngu·ªìn

vd: 
 interface Marth {
    static int sum(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        int result = Marth.sum(5, 6);   //g·ªçi tr·ª±c ti·∫øp qua Interface v√¨ k c√≥ l·ªõp con
        System.out.println(result);     // 11
    }
}

 ‚úÖ 3. Functional Interface

    Functional Interface l√† interface ch·ªâ c√≥ duy nh·∫•t 1 PH∆Ø∆†NG TH·ª®C TR·ª™U T∆Ø·ª¢NG tr·ª´ default ho·∫∑c static.
    N√≥ d√πng ƒë·ªÉ l√†m "khu√¥n" cho lambda expression ho·∫°t ƒë·ªông.

    üìå V√≠ d·ª• ƒë∆°n gi·∫£n:

    @FunctionalInterface
    interface MyPrinter {
        void print(String message); // duy nh·∫•t 1 abstract method
    }
Ch√∫ th√≠ch: Java cung c·∫•p annotation @FunctionalInterface ƒë·ªÉ ƒë√°nh d·∫•u functional interface

üß† Gi·∫£i th√≠ch:
@FunctionalInterface: annotation gi√∫p ki·ªÉm tra interface c√≥ ƒë√∫ng l√† "h√†m ch·ª©c nƒÉng" hay kh√¥ng.
Interface n√†y ch·ªâ c√≥ 1 method duy nh·∫•t l√† print(String) ‚Üí ƒë·ªß ƒëi·ªÅu ki·ªán l√† functional interface.

    üß™ D√πng Lambda v·ªõi Functional Interface::
    D√ôNG LAMBDA ƒê·ªÇ TRI·ªÇN KHAI PH∆Ø∆†NG TH·ª®C C·ª¶A INTERFACE METHOD V√å N√ì ƒêANG L√Ä TR·ª™U T∆Ø·ª¢NG
üìå V√≠ d·ª• c·ª• th·ªÉ:
üëá Interface truy·ªÅn th·ªëng:
    @FunctionalInterface
    interface MyPrinter {
        void print(String message); // ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng duy nh·∫•t
    }

üëá Tri·ªÉn khai b·∫±ng class b√¨nh th∆∞·ªùng:   
class ConsolePrinter implements MyPrinter {
    public void print(String message) {
        System.out.println("In: " + message);
    }
}

üëá Tri·ªÉn khai b·∫±ng lambda:
    MyPrinter printer = (msg) -> System.out.println("In: " + msg);
    printer.print("Hello!"); // In: Hello


    VD2:

    public class LambdaWithInterface {
    public static void main(String[] args) {
        // D√πng lambda ƒë·ªÉ "tri·ªÉn khai" method print c·ªßa interface
        MyPrinter printer = message -> System.out.println("In ra: " + message);

        // G·ªçi h√†m
        printer.print("Xin ch√†o Java 8!");
    }
}

üß† Gi·∫£i th√≠ch d·ªÖ hi·ªÉu:
Ph·∫ßn	                √ù nghƒ©a
message -> ...	H√†m nh·∫≠n 1 tham s·ªë (message) v√† th·ª±c hi·ªán in ra
printer.print(...)	G·ªçi h√†m nh∆∞ b√¨nh th∆∞·ªùng



‚úÖ M·ªôt s·ªë functional interface c√≥ s·∫µn trong Java:

Interface	         M√¥ t·∫£	         Tham s·ªë	     r·∫£ v·ªÅ
Runnable	    Ch·∫°y kh√¥ng c√≥ tham s·ªë	()	         void
Consumer<T>	    Nh·∫≠n v√†o, kh√¥ng tr·∫£ v·ªÅ	T v          oid
Function<T, R>	Nh·∫≠n T, tr·∫£ v·ªÅ R	     T	            R
Predicate<T>	Nh·∫≠n T, tr·∫£ v·ªÅ boolean	 T	        boolean
Supplier<T>	Kh√¥ng ƒë·∫ßu v√†o, tr·∫£ T	    ()	            T


üìå V√≠ d·ª• c·ª±c ƒë∆°n gi·∫£n v·ªõi Consumer<String>:

    import java.util.function.Consumer;

    public class ConsumerDemo {
        public static void main(String[] args) {
            Consumer<String> greeter = name -> System.out.println("Hello, " + name + "!");

            greeter.accept("An");
        }
    }

// Hello, An!



üß±Lambda Expression (bi·ªÉu th·ª©c h√†m)
‚ùì L√† g√¨?
Lambda l√† m·ªôt c√°ch vi·∫øt h√†m ng·∫Øn g·ªçn m√† kh√¥ng c·∫ßn t·∫°o l·ªõp ·∫©n danh.
 ƒê∆∞·ª£c d√πng khi b·∫°n c·∫ßn truy·ªÅn m·ªôt "ƒëo·∫°n x·ª≠ l√Ω" nh∆∞ tham s·ªë cho h√†m kh√°c.
 ‚úÖ C√∫ ph√°p c∆° b·∫£n:
    (parameters) -> expression

V√≠ d·ª•:
// Kh√¥ng d√πng lambda
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Hello from normal way!");
    }
};

// D√πng lambda
Runnable r2 = () -> System.out.println("Hello from lambda!");


üìå V√≠ d·ª• th·ª±c t·∫ø: s·∫Øp x·∫øp danh s√°ch

    import java.util.Arrays;
    import java.util.List;
    import java.util.Collections;

    public class LambdaExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("An", "B√¨nh", "C∆∞·ªùng", "√Ånh");

            // S·∫Øp x·∫øp theo th·ª© t·ª± b·∫£ng ch·ªØ c√°i, kh√¥ng d√πng lambda
            Collections.sort(names, new java.util.Comparator<String>() {
                public int compare(String a, String b) {
                    return a.compareTo(b);
                }
            });

            // V·ªõi lambda: ng·∫Øn g·ªçn h∆°n
            Collections.sort(names, (a, b) -> a.compareTo(b));

            System.out.println("Danh s√°ch sau khi s·∫Øp x·∫øp: " + names);
        }
    }

 // [An, B√¨nh, C∆∞·ªùng, √Ånh]


 ‚úÖMethod references (Tham chi·∫øu ph∆∞∆°ng th·ª©c)
üß† 1. Method Reference l√† g√¨?
    L√† c√°ch vi·∫øt r√∫t g·ªçn c·ªßa lambda khi lambda ch·ªâ ƒë∆°n gi·∫£n g·ªçi 1 method ƒë√£ c√≥ s·∫µn.
C√≥ 4 lo·∫°i ch√≠nh:
    üìå1. Static Method Reference
    üìå2. Instance Method Reference (ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ)
    üìå3. Instance Method of Arbitrary Object (c·ªßa class ‚Äì kh√¥ng c·ª• th·ªÉ)
    üìå4. Constructor Reference

üß™  V√≠ d·ª• minh h·ªça t·ª´ng lo·∫°i
1. Static Method Reference
    C√∫ ph√°p: ClassName::methodName

    public static void main(String[] args) {
          Consumer<String> print  = System.out::println;
          print.accept("Hello Java");
        }  --accept l√† ph∆∞∆°ng th·ª©c c√≥ s·∫µn trong Consumer
        //Hello Java

      

     public static void main(String[] args) {
            Function<String, Integer> f1 = String::length;
            System.out.println(f1.apply("Hello"));
        } --apply l√† ph∆∞∆°ng th·ª©c c√≥ s·∫µn trong Function

        @FunctionalInterface
    interface Calculator {
        int compute(int a, int b);
    }

    class MathUtils {
        public static int add(int x, int y) {
            return x + y;
        }
    }

    Calculator calc = MathUtils::add; // Tham chi·∫øu static
    System.out.println(calc.compute(3, 5)); // Output: 8



2. Instance Method Reference - Tham chi·∫øu ƒë·∫øn ph∆∞∆°ng th·ª©c c·ªßa m·ªôt ƒë·ªëi t∆∞·ª£ng (Instance Method)
    C√∫ ph√°p: objectName::methodName 

    public class InstanceExample {
        public void greet(String name) {
            System.out.println("Hello, " + name);
        }

        public static void main(String[] args) {
            InstanceExample obj = new InstanceExample();

            Consumer<String> c = obj::greet; // method reference
            c.accept("An");  // Output: Hello, An
        }
    }

3. Tham chi·∫øu ƒë·∫øn ph∆∞∆°ng th·ª©c c·ªßa m·ªôt l·ªõp b·∫•t k·ª≥ - Instance Method Reference 
    C√∫ ph√°p: ClassName::methodName

    List<String> names = Arrays.asList("an", "b√¨nh", "c∆∞·ªùng");
    names.forEach(String::toUpperCase); // AN, B√åNH, C∆Ø·ªúNG



 4. Constructor Reference - Tham chi·∫øu ƒë·∫øn Constructor
 t·∫°o object m·ªõi
    C√∫ ph√°p: ClassName::new

    public static void main(String[] args) {
            Supplier<ArrayList<String>> supplier = ArrayList::new;

            ArrayList<String> list = supplier.get(); // t·∫°o m·ªõi 1 ArrayList
            list.add("Java 8");
            System.out.println(list); // [Java 8]
        }

        VD 2:

    interface PersonFactory {
    Person create(String name);
    }

    class Person {
        String name;

        public Person(String name) {
            this.name = name;
        }
    }

    public class Main {
        public static void main(String[] args) {
            PersonFactory factory = Person::new; // Tham chi·∫øu constructor
            Person p = factory.create("Linh");
            System.out.
                    println(p.name); // Output: Linh
        }
    }





‚úÖ Functional Interface v√† Lambda trong th∆∞ vi·ªán java.util.function
1Ô∏è‚É£ Predicate<T>
üîπ M·ª•c ƒë√≠ch: ki·ªÉm tra ƒëi·ªÅu ki·ªán, tr·∫£ v·ªÅ true ho·∫∑c false.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    boolean test(T t);

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Predicate<String> isLongName = name -> name.length() > 5;

    System.out.println(isLongName.test("Linh"));     // false
    System.out.println(isLongName.test("Nguy·ªÖn"));   // true
    üß† D√πng nhi·ªÅu trong .filter(...) c·ªßa Stream.


2Ô∏è‚É£ Consumer<T>
üîπ M·ª•c ƒë√≠ch: th·ª±c hi·ªán h√†nh ƒë·ªông KH√îNG tr·∫£ v·ªÅ g√¨ (void), th∆∞·ªùng l√† in, ghi log, l∆∞u.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    void accept(T t);

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Consumer<String> printer = msg -> System.out.println("In: " + msg);
    printer.accept("Hello Java"); // Output: In: Hello Java
    üß† D√πng nhi·ªÅu v·ªõi .forEach(...) trong Stream.

3Ô∏è‚É£ Supplier<T>
üîπ M·ª•c ƒë√≠ch: cung c·∫•p m·ªôt gi√° tr·ªã m√† kh√¥ng c·∫ßn ƒë·∫ßu v√†o.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    T get();

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Supplier<Double> randomGenerator = () -> Math.random();
    System.out.println("S·ªë ng·∫´u nhi√™n: " + randomGenerator.get());
    üß† D√πng trong lazy loading, factory, sinh d·ªØ li·ªáu.

4Ô∏è‚É£ Function<T, R>
üîπ M·ª•c ƒë√≠ch: chuy·ªÉn ƒë·ªïi t·ª´ ki·ªÉu T sang ki·ªÉu R.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    R apply(T t);

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Function<String, Integer> toLength = s -> s.length();
    System.out.println(toLength.apply("Hello")); // Output: 5
    üß† D√πng nhi·ªÅu v·ªõi .map(...) trong Stream ƒë·ªÉ bi·∫øn ƒë·ªïi d·ªØ li·ªáu.



üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•
üî• Stream API ‚Äì X·ª≠ l√Ω d·ªØ li·ªáu "ki·ªÉu d√≤ng ch·∫£y"üî•
üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•


‚úÖPh√¢n lo·∫°i thao t√°c Stream
    Stream API cung c·∫•p hai lo·∫°i thao t√°c ch√≠nh:
    Intermediate Operations (C√°c thao t√°c trung gian):
    C√°c thao t√°c n√†y tr·∫£ v·ªÅ m·ªôt Stream m·ªõi
    Kh√¥ng th·ª±c thi ngay l·∫≠p t·ª©c
    V√≠ d·ª•: filter, map, sorted
    Terminal Operations (C√°c thao t√°c k·∫øt th√∫c):
    K·∫øt th√∫c Stream v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ ho·∫∑c th·ª±c hi·ªán h√†nh ƒë·ªông cu·ªëi c√πng
    Th·ª±c thi c√°c thao t√°c trung gian tr∆∞·ªõc ƒë√≥
    V√≠ d·ª•: forEach, collect, reduce


üß† Hi·ªÉu ƒë∆°n gi·∫£n:
    üîπ Stream API gi√∫p x·ª≠ l√Ω collection (List, Set, Array...) theo ki·ªÉu l·∫≠p tr√¨nh h√†m, ng·∫Øn g·ªçn, r√µ r√†ng, kh√¥ng c·∫ßn d√πng for, if truy·ªÅn th·ªëng.
    üîπ D·ªØ li·ªáu s·∫Ω ch·∫£y qua t·ª´ng b∆∞·ªõc nh∆∞: l·ªçc ‚Üí bi·∫øn ƒë·ªïi ‚Üí t√≠nh to√°n ‚Üí thu k·∫øt qu·∫£.

‚úÖ C·∫•u tr√∫c 3 b∆∞·ªõc khi d√πng Stream:
    Ngu·ªìn d·ªØ li·ªáu (collection, array, file...)
    C√°c b∆∞·ªõc trung gian (intermediate): filter, map, sorted, v.v.
    B∆∞·ªõc k·∫øt th√∫c (terminal): forEach, collect, count, sum...

üìå V√≠ d·ª• th·ª±c t·∫ø ƒë∆°n gi·∫£n nh·∫•t:
    B√†i to√°n:
    T·ª´ danh s√°ch t√™n, in ra nh·ªØng t√™n d√†i h∆°n 3 k√Ω t·ª±, v√† vi·∫øt hoa to√†n b·ªô.

    import java.util.*;
    import java.util.stream.*;

    public class Main {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("An", "Linh", "H√†", "Ng·ªçc");

            names.stream()                           // 1. B·∫Øt ƒë·∫ßu d√≤ng ch·∫£y d·ªØ li·ªáu
                .filter(name -> name.length() > 3) // 2. Gi·ªØ l·∫°i t√™n d√†i h∆°n 3 k√Ω t·ª±
                .map(String::toUpperCase)          // 3. Chuy·ªÉn sang vi·∫øt hoa
                .forEach(System.out::println);     // 4. In t·ª´ng c√°i ra
        }
    }
üü¢ K·∫øt qu·∫£: LINH
            NG·ªåC

  
‚úÖ M·ªôt s·ªë ph∆∞∆°ng th·ª©c th∆∞·ªùng g·∫∑p trong Stream:
Ph∆∞∆°ng th·ª©c	            M·ª•c ƒë√≠ch
filter()	    L·ªçc theo ƒëi·ªÅu ki·ªán
map()	        Bi·∫øn ƒë·ªïi t·ª´ng ph·∫ßn t·ª≠
sorted()	        S·∫Øp x·∫øp
limit()     	Gi·ªõi h·∫°n s·ªë ph·∫ßn t·ª≠
collect()	    Thu k·∫øt qu·∫£ v·ªÅ List, Set, Map...
count()	        ƒê·∫øm s·ªë ph·∫ßn t·ª≠
forEach()	    L·∫∑p qua t·ª´ng ph·∫ßn t·ª≠



üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•
‚úÖ Optional ‚Äì X·ª≠ l√Ω gi√° tr·ªã c√≥ th·ªÉ null trong Java 8
üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•

üß† V·∫•n ƒë·ªÅ tr∆∞·ªõc ƒë√¢y:
    Trong Java c≈©, khi m·ªôt bi·∫øn c√≥ th·ªÉ null, b·∫°n ph·∫£i ki·ªÉm tra th·ªß c√¥ng:
    if (user != null && user.getName() != null) {
        System.out.println(user.getName());
    }
    ‚ö†Ô∏è N·∫øu qu√™n check null, b·∫°n s·∫Ω g·∫∑p NullPointerException (l·ªói kinh ƒëi·ªÉn nh·∫•t c·ªßa Java).

üéØ Gi·∫£i ph√°p: Optional<T>
    Optional l√† m·ªôt "h·ªôp" c√≥ th·ªÉ ch·ª©a ho·∫∑c kh√¥ng ch·ª©a gi√° tr·ªã.
    Gi√∫p b·∫°n tr√°nh null m√† kh√¥ng c·∫ßn d√πng nhi·ªÅu if-else.

üì¶ C√°ch t·∫°o Optional
    Optional<String> name1 = Optional.of("Linh");       // C√≥ gi√° tr·ªã
    Optional<String> name2 = Optional.empty();          // Kh√¥ng c√≥ gi√° tr·ªã
    Optional<String> name3 = Optional.ofNullable(null); // C√≥ th·ªÉ null


    ‚úÖ C√°c ph∆∞∆°ng th·ª©c hay d√πng:
    Ph∆∞∆°ng th·ª©c                     	M√¥ t·∫£
    isPresent()	                 Tr·∫£ v·ªÅ true n·∫øu gi√° tr·ªã t·ªìn t·∫°i, ng∆∞·ª£c l·∫°i tr·∫£ v·ªÅ false
    isEmpty() (Java 11+):        Tr·∫£ v·ªÅ true n·∫øu Optional r·ªóng
    ifPresent(Consumer)	        N·∫øu c√≥ gi√° tr·ªã th√¨ l√†m g√¨
    map():               Bi·∫øn ƒë·ªïi gi√° tr·ªã b√™n trong Optional v√† tr·∫£ v·ªÅ m·ªôt Optional m·ªõi  
    get()	                L·∫•y gi√° tr·ªã (n·∫øu kh√¥ng c√≥ s·∫Ω l·ªói) s·∫Ω n√©m ra NoSuchElementException
    filter():                L·ªçc gi√° tr·ªã trong Optional theo m·ªôt ƒëi·ªÅu ki·ªán
    orElse(T)	            N·∫øu kh√¥ng c√≥ th√¨ tr·∫£ gi√° tr·ªã m·∫∑c ƒë·ªãnh (T)
    orElseGet(Supplier) 	N·∫øu kh√¥ng c√≥ th√¨ g·ªçi h√†m t·∫°o gi√° tr·ªã        optional.orElseGet(() -> "Generated value");
    orElseThrow()	            N·∫øu kh√¥ng c√≥ th√¨ n√©m l·ªói  orElseThrow(): N√©m ngo·∫°i l·ªá n·∫øu Optional r·ªóng


üìå V√≠ d·ª• ƒë∆°n gi·∫£n:

    Optional<String> name = Optional.ofNullable("Java");

    // 1. N·∫øu c√≥ gi√° tr·ªã ‚Üí in
    name.ifPresent(n -> System.out.println("T√™n: " + n));

    // 2. N·∫øu kh√¥ng c√≥ ‚Üí d√πng m·∫∑c ƒë·ªãnh
    String result = name.orElse("Kh√¥ng c√≥ t√™n"); //n·∫øu  k c√≥ th√¨ tr·∫£ gi√° tr·ªã m·∫∑c ƒë·ªãnh ·ªü ƒë√¢y l√† "Kh√¥ng c√≥ t√™n"
    System.out.println(result);

   üü¢ Output:  T√™n: Java
                    Java


‚ùå N·∫øu kh√¥ng d√πng Optional (c√°ch c≈©):
    String name = getName(); // c√≥ th·ªÉ null

    if (name != null) {
        System.out.println(name);
    } else {
        System.out.println("Kh√¥ng c√≥ t√™n");
    }

‚úÖ N·∫øu d√πng Optional:
    Optional<String> name = Optional.ofNullable(getName());
    System.out.println(name.orElse("Kh√¥ng c√≥ t√™n"));



üîí Ghi nh·ªõ:
Sai l·∫ßm th∆∞·ªùng g·∫∑p                                  C√°ch ƒë√∫ng
D√πng .get() m√† kh√¥ng check	            D√πng orElse(), ifPresent() ho·∫∑c orElseThrow()
L·∫°m d·ª•ng Optional trong                 D√πng Optional ch·ªß y·∫øu cho k·∫øt qu·∫£ tr·∫£ v·ªÅ
field ho·∫∑c tham s·ªë constructor          	


üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•
üïí Date-Time API m·ªõi (java.time) trong Java 8
üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•üî•

üì¶ C√°c class quan tr·ªçng
Class	                M√¥ t·∫£

LocalDate	    Ng√†y (yyyy-MM-dd), kh√¥ng c√≥ gi·ªù
LocalTime	        Gi·ªù (HH:mm:ss), kh√¥ng c√≥ ng√†y
LocalDateTime	    C·∫£ ng√†y v√† gi·ªù
ZonedDateTime	    C√≥ c·∫£ ng√†y gi·ªù v√† m√∫i gi·ªù
Instant	        M·ªëc th·ªùi gian t√≠nh t·ª´ 1970-01-01 (UTC)
Period	        Kho·∫£ng c√°ch ng√†y/th√°ng/nƒÉm
Duration	        Kho·∫£ng c√°ch gi·ªù/ph√∫t/gi√¢y

‚úÖ V√≠ d·ª• ƒë∆°n gi·∫£n:
üìÖ LocalDate:

import java.time.LocalDate;

public class Main {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();
        LocalDate birthday = LocalDate.of(2000, 12, 25);

        System.out.println("H√¥m nay: " + today);
        System.out.println("Sinh nh·∫≠t: " + birthday);
    }
}


‚è∞ LocalTime

import java.time.LocalTime;

public class Main {
    public static void main(String[] args) {
        LocalTime now = LocalTime.now();
        LocalTime fixed = LocalTime.of(14, 30); // 14:30

        System.out.println("B√¢y gi·ªù: " + now);
        System.out.println("Gi·ªù c·ªë ƒë·ªãnh: " + fixed);
    }
}


üïí LocalDateTime

import java.time.LocalDateTime;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime meeting = LocalDateTime.of(2025, 6, 2, 9, 0);   //2025-06-02T09:00

        System.out.println("Th·ªùi ƒëi·ªÉm hi·ªán t·∫°i: " + now);
        System.out.println("Cu·ªôc h·ªçp l√∫c: " + meeting);
    }
}


üßÆ So s√°nh, c·ªông/tr·ª´ ng√†y, gi·ªù

LocalDate today = LocalDate.now();
LocalDate nextWeek = today.plusWeeks(1);
LocalDate lastMonth = today.minusMonths(1);

System.out.println("Tu·∫ßn sau: " + nextWeek);
System.out.println("Th√°ng tr∆∞·ªõc: " + lastMonth);

üß† T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ng√†y:

LocalDate start = LocalDate.of(2020, 1, 1);
LocalDate end = LocalDate.of(2025, 1, 1);

Period period = Period.between(start, end);

System.out.println("Kho·∫£ng c√°ch: " +
    period.getYears() + " nƒÉm " +
    period.getMonths() + " th√°ng " +
    period.getDays() + " ng√†y");

//Kho·∫£ng c√°ch: 5 nƒÉm 0 th√°ng 0 ng√†y


üï∞ Format ng√†y gi·ªù (d√πng DateTimeFormatter)

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
        String formatted = now.format(formatter);

        System.out.println("ƒê·ªãnh d·∫°ng ƒë·∫πp: " + formatted);
    }
}
    


