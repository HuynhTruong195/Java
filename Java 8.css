
üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†
            üÜóüÜóüÜóüÜóüÜó  JAVA 8    üÜóüÜóüÜóüÜóüÜó
üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†


Java 8, ƒë∆∞·ª£c ph√°t h√†nh v√†o th√°ng 3 nƒÉm 2014, l√† m·ªôt trong nh·ªØng phi√™n b·∫£n quan tr·ªçng nh·∫•t trong l·ªãch s·ª≠ ph√°t tri·ªÉn c·ªßa Java. gi·ªõi thi·ªáu l·∫≠p tr√¨nh h√†m (Functional Programming) v√†o Java. 

‚úÖ 1. Ph∆∞∆°ng th·ª©c m·∫∑c ƒë·ªãnh (Default method) v√† ph∆∞∆°ng th·ª©c tƒ©nh (Static method) trong interface

Kh√°i ni·ªám: Ph∆∞∆°ng th·ª©c m·∫∑c ƒë·ªãnh trong interface ƒë·ªãnh nghƒ©a 1 h√†m chung m√† khi c√°c class con k·∫ø th·ª´a qua t·ª´ kh√≥a implement KH√îNG b·∫Øt bu·ªôc ph·∫£i ghi ƒë√® l·∫°i
L√Ω do s·ª≠ d·ª•ng: 
    Duy tr√¨ kh·∫£ nƒÉng t∆∞∆°ng th√≠ch ng∆∞·ª£c khi th√™m ph∆∞∆°ng th·ª©c m·ªõi v√†o interface
    Cho ph√©p c√†i ƒë·∫∑t s·∫µn logic m√† c√°c l·ªõp c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng

    Vd:
    interface Car {
    default void start() {
        System.out.println("Starting...");
        }
    }

    class Honda implements Car {}

    public class Main {
        public static void main(String[] args) {
            Honda test = new Honda();
            test.start();
        }
    }


 ‚úÖ 2. Ph∆∞∆°ng th·ª©c tƒ©nh (Static method)

 ƒê∆∞·ª£c ƒë·ªãnh nghƒ©a qua t·ª´ kh√≥a static. V√† CH·ªà THU·ªòC V·ªÄ  ch√≠nh Interface , kh√¥ng ph·∫£i c√°c l·ªõp con khi implement
 L√Ω do s·ª≠ d·ª•ng
    T·ªï ch·ª©c c√°c ph∆∞∆°ng th·ª©c ti·ªán √≠ch li√™n quan tr·ª±c ti·∫øp ƒë·∫øn interface
    TƒÉng t√≠nh m√¥-ƒëun v√† r√µ r√†ng trong m√£ ngu·ªìn

vd: 
 interface Marth {
    static int sum(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        int result = Marth.sum(5, 6);   //g·ªçi tr·ª±c ti·∫øp qua Interface v√¨ k c√≥ l·ªõp con
        System.out.println(result);     // 11
    }
}

 ‚úÖ 3. Functional Interface

    Functional Interface l√† interface ch·ªâ c√≥ duy nh·∫•t 1 PH∆Ø∆†NG TH·ª®C TR·ª™U T∆Ø·ª¢NG tr·ª´ default ho·∫∑c static.
    N√≥ d√πng ƒë·ªÉ l√†m "khu√¥n" cho lambda expression ho·∫°t ƒë·ªông.

    üìå V√≠ d·ª• ƒë∆°n gi·∫£n:

    @FunctionalInterface
    interface MyPrinter {
        void print(String message); // duy nh·∫•t 1 abstract method
    }
Ch√∫ th√≠ch: Java cung c·∫•p annotation @FunctionalInterface ƒë·ªÉ ƒë√°nh d·∫•u functional interface

üß† Gi·∫£i th√≠ch:
@FunctionalInterface: annotation gi√∫p ki·ªÉm tra interface c√≥ ƒë√∫ng l√† "h√†m ch·ª©c nƒÉng" hay kh√¥ng.
Interface n√†y ch·ªâ c√≥ 1 method duy nh·∫•t l√† print(String) ‚Üí ƒë·ªß ƒëi·ªÅu ki·ªán l√† functional interface.

    üß™ D√πng Lambda v·ªõi Functional Interface::
    D√ôNG LAMBDA ƒê·ªÇ TRI·ªÇN KHAI PH∆Ø∆†NG TH·ª®C C·ª¶A INTERFACE METHOD V√å N√ì ƒêANG L√Ä TR·ª™U T∆Ø·ª¢NG
üìå V√≠ d·ª• c·ª• th·ªÉ:
üëá Interface truy·ªÅn th·ªëng:
    @FunctionalInterface
    interface MyPrinter {
        void print(String message); // ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng duy nh·∫•t
    }

üëá Tri·ªÉn khai b·∫±ng class b√¨nh th∆∞·ªùng:   
class ConsolePrinter implements MyPrinter {
    public void print(String message) {
        System.out.println("In: " + message);
    }
}

üëá Tri·ªÉn khai b·∫±ng lambda:
    MyPrinter printer = (msg) -> System.out.println("In: " + msg);
    printer.print("Hello!"); // In: Hello


    VD2:

    public class LambdaWithInterface {
    public static void main(String[] args) {
        // D√πng lambda ƒë·ªÉ "tri·ªÉn khai" method print c·ªßa interface
        MyPrinter printer = message -> System.out.println("In ra: " + message);

        // G·ªçi h√†m
        printer.print("Xin ch√†o Java 8!");
    }
}

üß† Gi·∫£i th√≠ch d·ªÖ hi·ªÉu:
Ph·∫ßn	                √ù nghƒ©a
message -> ...	H√†m nh·∫≠n 1 tham s·ªë (message) v√† th·ª±c hi·ªán in ra
printer.print(...)	G·ªçi h√†m nh∆∞ b√¨nh th∆∞·ªùng



‚úÖ M·ªôt s·ªë functional interface c√≥ s·∫µn trong Java:

Interface	         M√¥ t·∫£	         Tham s·ªë	     r·∫£ v·ªÅ
Runnable	    Ch·∫°y kh√¥ng c√≥ tham s·ªë	()	         void
Consumer<T>	    Nh·∫≠n v√†o, kh√¥ng tr·∫£ v·ªÅ	T v          oid
Function<T, R>	Nh·∫≠n T, tr·∫£ v·ªÅ R	     T	            R
Predicate<T>	Nh·∫≠n T, tr·∫£ v·ªÅ boolean	 T	        boolean
Supplier<T>	Kh√¥ng ƒë·∫ßu v√†o, tr·∫£ T	    ()	            T


üìå V√≠ d·ª• c·ª±c ƒë∆°n gi·∫£n v·ªõi Consumer<String>:

    import java.util.function.Consumer;

    public class ConsumerDemo {
        public static void main(String[] args) {
            Consumer<String> greeter = name -> System.out.println("Hello, " + name + "!");

            greeter.accept("An");
        }
    }

// Hello, An!



üß±Lambda Expression (bi·ªÉu th·ª©c h√†m)
‚ùì L√† g√¨?
Lambda l√† m·ªôt c√°ch vi·∫øt h√†m ng·∫Øn g·ªçn m√† kh√¥ng c·∫ßn t·∫°o l·ªõp ·∫©n danh.
 ƒê∆∞·ª£c d√πng khi b·∫°n c·∫ßn truy·ªÅn m·ªôt "ƒëo·∫°n x·ª≠ l√Ω" nh∆∞ tham s·ªë cho h√†m kh√°c.
 ‚úÖ C√∫ ph√°p c∆° b·∫£n:
    (parameters) -> expression

V√≠ d·ª•:
// Kh√¥ng d√πng lambda
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Hello from normal way!");
    }
};

// D√πng lambda
Runnable r2 = () -> System.out.println("Hello from lambda!");


üìå V√≠ d·ª• th·ª±c t·∫ø: s·∫Øp x·∫øp danh s√°ch

    import java.util.Arrays;
    import java.util.List;
    import java.util.Collections;

    public class LambdaExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("An", "B√¨nh", "C∆∞·ªùng", "√Ånh");

            // S·∫Øp x·∫øp theo th·ª© t·ª± b·∫£ng ch·ªØ c√°i, kh√¥ng d√πng lambda
            Collections.sort(names, new java.util.Comparator<String>() {
                public int compare(String a, String b) {
                    return a.compareTo(b);
                }
            });

            // V·ªõi lambda: ng·∫Øn g·ªçn h∆°n
            Collections.sort(names, (a, b) -> a.compareTo(b));

            System.out.println("Danh s√°ch sau khi s·∫Øp x·∫øp: " + names);
        }
    }

 // [An, B√¨nh, C∆∞·ªùng, √Ånh]


 ‚úÖMethod references (Tham chi·∫øu ph∆∞∆°ng th·ª©c)
üß† 1. Method Reference l√† g√¨?
    L√† c√°ch vi·∫øt r√∫t g·ªçn c·ªßa lambda khi lambda ch·ªâ ƒë∆°n gi·∫£n g·ªçi 1 method ƒë√£ c√≥ s·∫µn.
C√≥ 4 lo·∫°i ch√≠nh:
    üìå1. Static Method Reference
    üìå2. Instance Method Reference (ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ)
    üìå3. Instance Method of Arbitrary Object (c·ªßa class ‚Äì kh√¥ng c·ª• th·ªÉ)
    üìå4. Constructor Reference

üß™  V√≠ d·ª• minh h·ªça t·ª´ng lo·∫°i
1. Static Method Reference
    C√∫ ph√°p: ClassName::methodName

    public static void main(String[] args) {
          Consumer<String> print  = System.out::println;
          print.accept("Hello Java");
        }  --accept l√† ph∆∞∆°ng th·ª©c c√≥ s·∫µn trong Consumer
        //Hello Java

      

     public static void main(String[] args) {
            Function<String, Integer> f1 = String::length;
            System.out.println(f1.apply("Hello"));
        } --apply l√† ph∆∞∆°ng th·ª©c c√≥ s·∫µn trong Function

        @FunctionalInterface
    interface Calculator {
        int compute(int a, int b);
    }

    class MathUtils {
        public static int add(int x, int y) {
            return x + y;
        }
    }

    Calculator calc = MathUtils::add; // Tham chi·∫øu static
    System.out.println(calc.compute(3, 5)); // Output: 8



2. Instance Method Reference - Tham chi·∫øu ƒë·∫øn ph∆∞∆°ng th·ª©c c·ªßa m·ªôt ƒë·ªëi t∆∞·ª£ng (Instance Method)
    C√∫ ph√°p: objectName::methodName 

    public class InstanceExample {
        public void greet(String name) {
            System.out.println("Hello, " + name);
        }

        public static void main(String[] args) {
            InstanceExample obj = new InstanceExample();

            Consumer<String> c = obj::greet; // method reference
            c.accept("An");  // Output: Hello, An
        }
    }

3. Tham chi·∫øu ƒë·∫øn ph∆∞∆°ng th·ª©c c·ªßa m·ªôt l·ªõp b·∫•t k·ª≥ - Instance Method Reference 
    C√∫ ph√°p: ClassName::methodName

    List<String> names = Arrays.asList("an", "b√¨nh", "c∆∞·ªùng");
    names.forEach(String::toUpperCase); // AN, B√åNH, C∆Ø·ªúNG



 4. Constructor Reference - Tham chi·∫øu ƒë·∫øn Constructor
 t·∫°o object m·ªõi
    C√∫ ph√°p: ClassName::new

    public static void main(String[] args) {
            Supplier<ArrayList<String>> supplier = ArrayList::new;

            ArrayList<String> list = supplier.get(); // t·∫°o m·ªõi 1 ArrayList
            list.add("Java 8");
            System.out.println(list); // [Java 8]
        }

        VD 2:

    interface PersonFactory {
    Person create(String name);
    }

    class Person {
        String name;

        public Person(String name) {
            this.name = name;
        }
    }

    public class Main {
        public static void main(String[] args) {
            PersonFactory factory = Person::new; // Tham chi·∫øu constructor
            Person p = factory.create("Linh");
            System.out.
                    println(p.name); // Output: Linh
        }
    }





‚úÖ Functional Interface v√† Lambda trong th∆∞ vi·ªán java.util.function
1Ô∏è‚É£ Predicate<T>
üîπ M·ª•c ƒë√≠ch: ki·ªÉm tra ƒëi·ªÅu ki·ªán, tr·∫£ v·ªÅ true ho·∫∑c false.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    boolean test(T t);

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Predicate<String> isLongName = name -> name.length() > 5;

    System.out.println(isLongName.test("Linh"));     // false
    System.out.println(isLongName.test("Nguy·ªÖn"));   // true
    üß† D√πng nhi·ªÅu trong .filter(...) c·ªßa Stream.


2Ô∏è‚É£ Consumer<T>
üîπ M·ª•c ƒë√≠ch: th·ª±c hi·ªán h√†nh ƒë·ªông KH√îNG tr·∫£ v·ªÅ g√¨ (void), th∆∞·ªùng l√† in, ghi log, l∆∞u.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    void accept(T t);

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Consumer<String> printer = msg -> System.out.println("In: " + msg);
    printer.accept("Hello Java"); // Output: In: Hello Java
    üß† D√πng nhi·ªÅu v·ªõi .forEach(...) trong Stream.

3Ô∏è‚É£ Supplier<T>
üîπ M·ª•c ƒë√≠ch: cung c·∫•p m·ªôt gi√° tr·ªã m√† kh√¥ng c·∫ßn ƒë·∫ßu v√†o.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    T get();

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Supplier<Double> randomGenerator = () -> Math.random();
    System.out.println("S·ªë ng·∫´u nhi√™n: " + randomGenerator.get());
    üß† D√πng trong lazy loading, factory, sinh d·ªØ li·ªáu.

4Ô∏è‚É£ Function<T, R>
üîπ M·ª•c ƒë√≠ch: chuy·ªÉn ƒë·ªïi t·ª´ ki·ªÉu T sang ki·ªÉu R.
üîπ Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng:
    R apply(T t);

üîπ V√≠ d·ª• th·ª±c t·∫ø:

    Function<String, Integer> toLength = s -> s.length();
    System.out.println(toLength.apply("Hello")); // Output: 5
    üß† D√πng nhi·ªÅu v·ªõi .map(...) trong Stream ƒë·ªÉ bi·∫øn ƒë·ªïi d·ªØ li·ªáu.
