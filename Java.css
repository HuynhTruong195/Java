🧠 Java là gì?
Java là một ngôn ngữ lập trình hướng đối tượng, đa nền tảng, mạnh mẽ và phổ biến toàn cầu.

Được dùng để phát triển:
✅ Ứng dụng web (Spring, JSP)
✅ Phần mềm desktop (Swing, JavaFX)
✅ Ứng dụng Android
✅ Hệ thống backend doanh nghiệp

🔹 1. Đặc điểm nổi bật của Java
Đặc điểm	Giải thích đơn giản
    Đa nền tảng	Viết một lần, chạy mọi nơi (Write once, run anywhere)
    Hướng đối tượng	Mọi thứ đều là đối tượng → dễ tổ chức code
    Bảo mật cao	Chạy trong máy ảo (JVM) → tránh lỗi hệ thống
    Thư viện phong phú	Có sẵn rất nhiều thư viện (collections, IO, network...)
    Đa luồng (multithreading)	Xử lý nhiều việc cùng lúc hiệu quả

🔹 2. Cấu trúc chương trình Java cơ bản

    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, world!");
        }
    }

Thành phần	Vai trò
    class	Mỗi chương trình Java phải có ít nhất một class
    main method	Điểm bắt đầu chương trình
    System.out.println()	In ra màn hình

🔹 3. Kiến thức nền tảng Java cần học

✅ A. Biến và Kiểu dữ liệu

    int age = 20;
    String name = "Anna";
    boolean isStudent = true;

✅ B. Câu lệnh điều kiện

    if (age > 18) {
    System.out.println("Adult");
    } else {
    System.out.println("Teenager");
    }

✅ C. Vòng lặp

    for (int i = 0; i < 5; i++) {
    System.out.println(i);
    }

✅ D. Mảng

    int[] scores = {90, 85, 70};
    System.out.println(scores[1]); // 85

✅ E. Hàm (method)

    public static int sum(int a, int b) {
    return a + b;

    }
🔹 4. Hướng đối tượng (OOP) trong Java

     tính chất quan trọng:

Tính chất	            Giải thích
Encapsulation	    Đóng gói dữ liệu và hành vi
Inheritance	        Kế thừa từ class cha
Polymorphism	    Đa hình: một hàm có nhiều cách dùng
Abstraction	        Trừu tượng: ẩn chi tiết không cần thiết

📌 Ví dụ đơn giản:

    class Animal {
        void speak() {
            System.out.println("Animal speaks");
        }
    }

    class Dog extends Animal {
        void speak() {
            System.out.println("Dog barks");
        }
    }


    ////////////// JDK, JRE , JVM /////////////
✅ 1. JVM – Java Virtual Machine (Máy ảo Java)
➤ Là gì?
    JVM là máy ảo giúp chạy chương trình Java.

    🔹 Chức năng:
    Chạy mã bytecode (.class) đã được biên dịch từ mã Java (.java).

    Quản lý bộ nhớ, dọn rác (Garbage Collector).

    Đảm bảo Java chạy giống nhau trên mọi hệ điều hành.

🧠 Ví dụ:
Khi bạn chạy chương trình Java:

    java HelloWorld
    → JVM là thành phần thực sự thực thi file HelloWorld.class.

✅ 2. JRE – Java Runtime Environment
➤ Là gì?
    JRE là môi trường chạy Java — gồm:

    JVM

    Thư viện Java chuẩn (API: java.util, java.io, v.v.)

    🔹 Chức năng:
    Cho phép chạy các chương trình Java đã biên dịch.

    Không chứa trình biên dịch — chỉ để chạy, không để viết/mã hóa.

📦 Gồm những gì?
    JVM ✅

    Core Libraries ✅

    File cấu hình runtime ✅

🧠 Khi nào dùng?
    Nếu bạn chỉ muốn chạy ứng dụng Java (người dùng cuối), thì JRE là đủ.

✅ 3. JDK – Java Development Kit
➤ Là gì?
    JDK là bộ công cụ phát triển Java.

    🔹 Chức năng:
    Dùng để viết, biên dịch và chạy chương trình Java.

📦 Gồm những gì?
Thành phần              	Vai trò
JVM	                     Để chạy chương trình
JRE                    	Để hỗ trợ runtime
javac	                Trình biên dịch .java → .class
javadoc, jar, jdb...	Các công cụ phát triển khác

🧱 Minh họa thực tế:
    Giả sử bạn có chương trình HelloWorld.java:

    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello Java!");
        }
    }
    ✅ Khi bạn:
    javac HelloWorld.java  // Biên dịch (JDK)
    java HelloWorld        // Chạy (JRE → JVM)

📌 Kết luận:
🛠 JDK: Dành cho lập trình viên – để viết và chạy code

⚙ JRE: Dành cho người dùng – để chạy chương trình Java

💻 JVM: Máy ảo – nơi chương trình Java thực sự chạy


/////////////////// BIẾN VÀ DỮ LIỆU ////////////////

✅ 1. Biến là gì?
Biến (Variable) là vùng nhớ dùng để lưu trữ giá trị mà chương trình có thể thay đổi trong quá trình thực thi.

🔹 Cú pháp khai báo biến:

    kiểu_dữ_liệu tên_biến = giá_trị;
🔹 Ví dụ:

    int age = 25;
    String name = "John";
    boolean isStudent = true;

✅ 2. Các loại biến trong Java
Loại biến	                Phạm vi sử dụng	                              Đặc điểm
Biến cục bộ	        Trong phương thức, vòng lặp...	                Phải gán giá trị trước khi dùng
Biến instance        Khai báo trong class, ngoài method	             Gắn với từng đối tượng
Biến static           Khai báo trong class với từ khóa static	    Thuộc về class, không thuộc riêng đối tượng nào

✅ 3. Kiểu dữ liệu trong Java
Java có 2 nhóm chính:

🟢 A. Kiểu dữ liệu nguyên thủy (Primitive)
    Kiểu	    Kích thước	    Giá trị đại diện
    int	        4 byte	        Số nguyên (1, 2, 100)
    float	    4 byte	    Số thực (3.14f)
    double	    8 byte	    Số thực chính xác cao -2^63 -> 2^63-1
    char	    2 byte	    Ký tự đơn ('a', 'A')
    boolean	    1 bit   	true / false
    byte	    1 byte	    Số nhỏ (-128 đến 127)
    short	    2 byte  	Số nguyên nhỏ
    long	    8 byte	    Số nguyên lớn

📌 Ví dụ:

    int age = 20;
    double price = 99.5;
    char grade = 'A';
    boolean passed = true;

🔵 B. Kiểu tham chiếu (Reference)
Là kiểu dữ liệu đại diện cho đối tượng hoặc mảng:

    Kiểu dữ liệu	Mô tả
    String	Chuỗi ký tự ("Hello")
    Array	Mảng các phần tử
    Class, Object	Đối tượng

📌 Ví dụ:

    String name = "Alice";
    int[] numbers = {1, 2, 3, 4};

✅ 4. Ép kiểu dữ liệu

   🔸 Ép kiểu tự động (implicit), kiểu ngầm định
   
 ép kiểu dữ liệu kích thước Lớn sang dữ liệu kích thước nhỏ hơn.
 vd :
    short sh = 100;
    int i = 10000;
    int intValue = sh; KHÔNG GÂY RA LỖI DO TỪ LỚN VỀ NHỎ HỢP LỆ
vd2:
   int x = 10;
    double y = x; 
     Tự động ép kiểu int sang double //: 10.0

   
     🔸 Ép kiểu tường minh (explicit):
 ép kiểu dữ liệu nhỏ sang dữ liệu kích thước  lớn hơn. gây lỗi, tràn dữ liệu
 vd: 
 short shortValue = (short) i;

 vd2:
     double d = 9.8;
    int i = (int) d; 
     Tự động ép kiểu double sang int // Kết quả: 9
 
✅ 5. Quy tắc đặt tên biến
    Bắt đầu bằng chữ cái, _ (gạch dưới), hoặc ký tự $

    Không bắt đầu bằng số

    Dùng camelCase: studentName, totalScore

    Không được trùng với từ khóa (int, class, return,...)

✅ Tổng kết nhanh:

    Thành phần              	Mô tả
    Biến	                Dùng để lưu trữ dữ liệu
    Kiểu dữ liệu             Quy định dạng giá trị biến có thể nhận
    Kiểu nguyên thủy    	int, float, boolean, char...
    Kiểu tham chiếu	            String, Array, Class, ObjecT



    ///////////QUẢN LÝ BỘ NHỚ TRONG JAVA /////////////

✅ 1. Bộ nhớ trong Java được chia làm 2 vùng chính:
🔹 A. Stack Memory (Bộ nhớ ngăn xếp)
    Chứa biến cục bộ, lời gọi hàm (method).

    Mỗi lần gọi một method → một frame được đẩy vào Stack.

    Sau khi method chạy xong → frame đó bị xóa khỏi Stack.

    Nhanh và tự động giải phóng.

📌 Ví dụ:

    public void sum() {
    int a = 5;  // nằm trong Stack
    }

🔹 B. Heap Memory (Bộ nhớ vùng nhớ động)
    Chứa đối tượng và biến instance (non-static).

    Được cấp phát bằng từ khóa new.

    Phân phối chậm hơn Stack, nhưng linh hoạt hơn.

    Được quản lý bởi Garbage Collector.

📌 Ví dụ:

    Student s = new Student();  // Đối tượng Student nằm trong Heap



 🔹 NGOÀI RA CÒN CÓ Code Segment và Data Segment
    Code Segment:

Đinh nghĩa:

    Code Segment là nơi lưu trữ mã lệnh của chương trình, hay còn gọi là tập hợp các câu lệnh mà CPU thực thi.

Trong Java:

    Code Segment tương ứng với Method Area trong JVM (Java Virtual Machine).
    Chức năng:
    Lưu thông tin về các class đã được tải (metadata).
    Lưu trữ mã bytecode của các phương thức.
    Chứa constant pool (bảng hằng số, ví dụ các chuỗi String không thay đổi).
    Ví dụ: Khi bạn khai báo final int counter = 0;, biến counter được lưu trong vùng Method Area.
    
Data Segment:
    Định nghĩa:

    Data Segment chứa các biến toàn cục và các biến tĩnh (static), được cấp phát khi chương trình chạy và tồn tại suốt vòng đời của chương trình.
 Trong Java:

    Biến tĩnh (static) và hằng số (final static) được lưu trong Method Area.
    Constant pool của mỗi lớp chứa các giá trị hằng được sử dụng trong chương trình, ví dụ chuỗi "Hello" hoặc số 3.14.


✅ 2. Bộ nhớ Method Area & MetaSpace (Java 8+)

    Method Area (trước Java 8): chứa thông tin về class (biến static, method, constructor, v.v.)

    MetaSpace (từ Java 8): thay thế Method Area, nằm ngoài Heap, giúp quản lý class tốt hơn và mở rộng theo hệ điều hành.


✅ 3. Garbage Collector (GC) – Bộ gom rác
    Là cơ chế tự động xóa đối tượng không còn sử dụng trong Heap để tránh rò rỉ bộ nhớ.

    Không cần tự free() như trong C/C++.

    GC sẽ chạy khi:

    Bộ nhớ gần đầy

    Hệ thống rảnh

    Lập trình viên gọi System.gc() (chỉ là gợi ý, không bắt buộc JVM thực hiện)

📌 GC sẽ thu gom đối tượng nào?

Đối tượng không còn tham chiếu từ bất kỳ biến nào nữa.

🔸 Ví dụ:

    Student s1 = new Student();  // s1 tham chiếu đối tượng Student
    s1 = null;  // không còn tham chiếu → GC sẽ xóa


✅ 4. Cách sử dụng bộ nhớ hiệu quả
    Cách làm	                                        Mục đích
    Dùng biến cục bộ thay vì toàn cục	        Giải phóng nhanh hơn (Stack vs Heap)
    Tránh giữ tham chiếu không cần thiết	        Giúp GC dọn rác đúng lúc
    Đóng file, stream sau khi dùng	            Giải phóng tài nguyên hệ thống
    Dùng try-with-resources	                Tự động đóng stream, connection, etc.

✅ Tổng kết:
    Vùng nhớ	        Dùng để lưu gì?	                     Giải phóng như thế nào?
    Stack       	Biến cục bộ, lời gọi hàm	             Tự động khi hàm kết thúc
    Heap	        Đối tượng, biến instance (new)	          Bởi Garbage Collector (GC)
    MetaSpace   	Thông tin về class, static fields	        Tự quản lý, mở rộng theo OS



///////////// CÁC TOÁN TỬ TRONG JAVA ///////////

✅ 1. Toán tử số học (Arithmetic Operators)

    Toán tử     	Ý nghĩa	        Ví dụ (a = 10, b = 3)	    Kết quả
    +	            Cộng	            a + b	                    13
    -	            Trừ	                a - b	                    7
    *	            Nhân	            a * b	                    30
    /	            Chia	            a / b	                     3
    %	        Chia lấy dư         	a % b	                     1

✅ 2. Toán tử gán (Assignment Operators)

    Toán tử	        Ý nghĩa	        Ví dụ	        Tương đương với
    =	            Gán	            a = 5	        Gán giá trị
    +=	        Cộng rồi gán	    a += 2	        a = a + 2
    -=	        Trừ rồi gán     	a -= 2	        a = a - 2
    *=      	Nhân rồi gán	    a *= 3          a = a * 3
    /=	        Chia rồi gán	    a /= 2	        a = a / 2
    %=	        Lấy dư rồi gán	    a %= 2      	a = a % 2

✅ 3. Toán tử so sánh (Relational Operators)
    Toán tử	        Ý nghĩa	        Ví dụ	        Kết quả
    ==	            So sánh bằng	a == b	        false
    !=                Khác nhau	    a != b	        true
    >	                Lớn hơn	     a > b	        true
    <	                Nhỏ hơn	    a < b	        false
    >=	         Lớn hơn hoặc bằng	  a >= b	    true
    <=	          Nhỏ hơn hoặc bằng	   a <= b	    false

✅ 4. Toán tử logic (Logical Operators)

    Toán tử	        Ý nghĩa	        Ví dụ   	    Kết quả
    &&          	AND – Và	(a > 5 && b < 5)	true
    ||		                            ||	        OR – Hoặc
    !	          NOT – Phủ định	!(a > b)	    false


✅ 5. Toán tử tăng/giảm (Increment/Decrement)

    Toán tử	      Ý nghĩa	        Ví dụ       	Kết quả
    ++a	          Tăng trước	      ++a	        11
    a++	            Tăng sau	        a++	        10 (rồi thành 11)
    --a	            Giảm trước	        --a	         9
    a--	            Giảm sau	        a--	        10 (rồi thành 9)

✅ 6. Toán tử điều kiện 3 ngôi (Ternary Operator)

    String result = (a > b) ? "a Lớn hơn b" : "a Không lớn hơn b";
    Nếu điều kiện đúng → lấy giá trị trước :

    Nếu sai → lấy giá trị sau :

✅ 7. Toán tử bit (ít dùng cho người mới)

    Toán tử       Mô tả
    &	        AND bit
    `	        `
    ^	        XOR bit
    ~	        NOT bit
    <<	        Dịch trái
    >>	        Dịch phải


✅ 8. Toán tử instanceof
Dùng để kiểm tra một đối tượng có thuộc kiểu class nào không.

    if (obj instanceof String) {
        System.out.println("Là chuỗi");
    }


✅ Tổng kết:
    Nhóm toán tử	                   Công dụng
    Số học	                    Tính toán (+, -, *, /, %)
    Gán	                        Gán và tính nhanh (+=, -=...)
    So sánh	                    So sánh điều kiện (==, !=, >...)
    Logic	                    Kết hợp điều kiện (&&,
    Tăng/Giảm	                Tự động tăng hoặc giảm biến
    3 ngôi	                    If/else ngắn gọn
    Bit                     	Xử lý ở mức bit (ít dùng)
    instanceof	                Kiểm tra kiểu dữ liệu đối tượng




    ////// NHẬP/ XUẤT TRONG JAVA
 ✅ 1. Nhập xuất từ bàn phím (console)
🔹 Nhập (input) bằng Scanner   

    import java.util.Scanner;

    public class Main {
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in); // tạo đối tượng Scanner

            System.out.print("Nhập tên của bạn: ");
            String name = scanner.nextLine(); // đọc chuỗi

            System.out.print("Nhập tuổi của bạn: ");
            int age = scanner.nextInt(); // đọc số nguyên

            System.out.println("Xin chào " + name + ", bạn " + age + " tuổi.");
        }
    }

✅ Một số hàm trong Scanner:

    Phương thức	                Công dụng
    nextLine()	        Nhập cả dòng (chuỗi)
    next()	                Nhập 1 từ (ngừng khi gặp khoảng trắng)
    nextInt()	            Nhập số nguyên
    nextDouble()	        Nhập số thực
    hasNextInt()	    Kiểm tra xem còn dữ liệu để đọc không

✅ 2. Xuất (output) ra màn hình

    Dùng System.out.print() hoặc System.out.println()

    System.out.print("Hello");      // không xuống dòng
    System.out.println(" world!");  // có xuống dòng

có thể dùng printf() để định dạng:

    System.out.printf("Tuổi bạn là %d\n", 20);       // %d: số nguyên
    System.out.printf("Điểm: %.2f", 9.2456);         // %f: số thực, .2 là 2 chữ số thập phân


    VỚI CÁC ĐỊNH DẠNG KIỂU DỮ LIỆU
    int - %d
    float - %f
    String - %s      vd thêm đấu - sẽ căn trái + sẽ căn phải. nếu thêm số ô chiếm thì thêm 10 nếu muốn chiếm 10 ô . vd %-10 // căn theo lề trái và 10 ký tự
    char - %c
    boolean - %b
    double - %f

 ///   BÀI TOÁN ỨNG DỤNG TÍNH CHU VI VÀ DIỆN TÍCH VỚI INPUT NHẬP TỪ BÀN PHÍM ///

 import java.util.Scanner;

    public class Main {
        public static void main(String[] args) {
    // nhập chiều dài và chiều  rộng từ bàn phím
            Scanner sc = new Scanner(System.in);
            System.out.println("Nhập chiều dài hình chữ nhật");
            // khai báo biến hứng input ng dùng nhập
            double chieuDai =  sc.nextDouble();
            System.out.println("Nhập chiều rộng hình chữ nhật");
            double chieuRong =  sc.nextDouble();

            //Tính diện tích
            double dienTich = chieuDai * chieuRong;
            //Tính chu vi
            double chuVi = 2*(chieuDai+chieuRong);

            //In ra màn hình
            System.out.printf("chiều dài: %.2f và chiều Rộng : %.2f\n", chieuDai, chieuRong);
            System.out.printf("Diện tích là : %.2f , Chu vi là : %.2f", dienTich, chuVi);


        }
    }


🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
//// CÂU LỆNH ĐIỀU KHIỂN///

✅1. Câu lệnh rẽ nhánh (if / else , switch / case)
    if, else if, else
    VD:
        int age = 18;
    if (age >= 18) {
        System.out.println("Đủ tuổi.");
    } else {
        System.out.println("Chưa đủ tuổi.");
    }

    switch / case 
    VD:
    int day = 3;
    switch (day) {
        case 1:
            System.out.println("Thứ Hai");
            break;
        case 2:
            System.out.println("Thứ Ba");
            break;
        default:
            System.out.println("Không biết ngày nào");
    }

✅2.  Câu lệnh lặp (for, while, do-while)

    for: 
        for (int i = 0; i < 5; i++) {
        System.out.println("Lần " + i);
    }

    while: 
        int i = 0;
    while (i < 5) {
        System.out.println("Lần " + i);
        i++;
    }

    do-while:
        int i = 0;
    do {
        System.out.println("Lần " + i);
        i++;
    } while (i < 5);

    for-each: 

     String [] fruits = {"apple","orange","banana"};
        for(String fruit: fruits){
            System.out.println(fruit);

✅3. Câu lệnh nhảy (break, continue, return)

    break – thoát khỏi vòng lặp hoặc switch

        for (int i = 0; i < 10; i++) {
        if (i == 5) break;
        System.out.println(i);
    }

    continue – bỏ qua vòng lặp hiện tại

        for (int i = 0; i < 5; i++) {
        if (i == 2) continue;
        System.out.println(i);
    }

    return – trả giá trị về từ phương thức

        public int add(int a, int b) {
        return a + b;
    }

    vd:
    
    public static void printArray() {
        for (int i = 0; i <= 20; i++) {
            if (i==15){
                return;
            }
            System.out.printf("%d ",i);
        }
    }

✅4. Try...Catch
Trong JavaScript, try...catch là một cấu trúc dùng để bắt lỗi (error handling). Khi một đoạn mã trong try gặp lỗi, chương trình sẽ không bị dừng lại, mà sẽ chuyển sang catch để xử lý lỗi đó.

🔹 Cấu trúc cơ bản:
        try {
        // Code có thể gây ra lỗi
    } catch (ExceptionType e) {
        // Code xử lý lỗi
    }
🔹 Ví dụ đơn giản:
    public class Main {
        public static void main(String[] args) {
            try {
                int a = 10 / 0; // lỗi chia cho 0
                System.out.println("Kết quả: " + a);
            } catch (ArithmeticException e) {
                System.out.println("Lỗi: " + e.getMessage());
            }
        }
    }

    Kết quả: Lỗi: / by zero

🔹 Một số exception thường gặp trong Java:
Exception                           	Mô tả
ArithmeticException     	        Lỗi toán học, ví dụ chia cho 0
NullPointerException	             Truy cập biến null
ArrayIndexOutOfBoundsException	    Truy cập sai chỉ số mảng
FileNotFoundException	            Không tìm thấy file
IOException                     	Lỗi vào/ra
NumberFormatException	            Lỗi khi chuyển chuỗi thành số


BÀI TẬP 01-SS3
LỖI SO SÁNH
    System.out.println("Nhập giới tính (1: Nam, 0: Nữ");
            String gender = sc.nextLine();
            if (gender == "1") {
                gender = "Nam";
            } else {
                gender = "Nữ";
            }
❌ Lỗi bạn đang gặp: Bạn đang gặp một lỗi rất phổ biến trong Java: so sánh chuỗi (String) bằng toán tử == thay vì dùng .equals().
Toán tử == trong Java so sánh địa chỉ ô nhớ, không phải nội dung chuỗi. Do đó, mặc dù bạn nhập "1", nó không chắc giống "1" mà bạn viết trong code (vì khác địa chỉ ô nhớ), nên điều kiện bị sai → rơi vào else.
✅ Cách sửa đúng:
if (gender.equals("1")) {
    gender = "Nam";
} else {
    gender = "Nữ";
}

📌 Mẹo ghi nhớ:
Dùng == để so sánh kiểu nguyên thủy (int, boolean, char...)

Dùng .equals() để so sánh chuỗi hoặc đối tượng

vd2: 
String a = new String("Hello");
String b = new String("Hello");

System.out.println(a == b);      // ❌ false (khác vùng nhớ)
System.out.println(a.equals(b)); // ✅ true  (giống nội dung)


CÁCH IN ĐỊNH DẠNG TIỀN VD 50,000

System.out.printf("Đơn giá: %,10.2f ",price);
dấu , là cứ 3 số thì dùng ,
số 10 là 10 ký tự
.2 là sau dấu . thì lấy thêm 2 số vd 10.00

in ra ký tự % trong prinf thì dùng 2 lần %% vd 10%%



🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
//////////// MẢNG Array ///////////////

🔷 KHÁI QUÁT CHUNG VỀ MẢNG TRONG JAVA
1. Mảng (Array) là gì?

Mảng là một tập hợp các phần tử có cùng kiểu dữ liệu (int, String, boolean, v.v.), được lưu trữ liên tục trong bộ nhớ.

Mỗi phần tử trong mảng được truy cập thông qua chỉ số (index), bắt đầu từ 0.

2. Cách khai báo mảng trong Java

Java hỗ trợ 3 cách khai báo mảng:

    ✅ Cách 1: Khai báo không gán giá trị

    int [] numbers;
    String [] names;

    ✅ Cách 2: Khai báo mảng, khởi tạo kích thước:
    int [] numbers = new int[5];  mảng kiểu int có 5 phần tử
    String [] names = new String[3]; mảg kiểu string có 3 phần tử

 Khởi tạo mảng 1 chiều hoặc 2 chiều:
    int[] numbers = new int[5]; // mảng 1 chiều
    int[][] matrix = new int[3][3]; // mảng 2 chiều
Khởi tạo thông qua vòng lặp: có thể dùng vòng lặp khi chưa biết giá trị của các phần tử

int [] numbers = new int[5];
for (int i = 0; i < numbers.length; i++) {
    numbers[i]= i + 1;  gán giá trị cho từng phần tử trong mảng
}


3. Cách truy cập phần tử của mảng qua chỉ số (index):

int [] numbers = new int[5];
numbers[0] = 5; gán giá trị 5 cho phần tử đầu tiên của mảng numbers
numbers[2] = 10; gán giá trị 10 cho phần tử có index 3 của mảng 

4. 🔁 Duyệt mảng bằng vòng lặp for và for-each

    for (int i = 0; i < numbers.length; i++) {
        System.out.println(numbers[i]);
    }

    // for-each
    for (int num : numbers) {
        System.out.println(num);
    }


🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
 🆗🆗🆗🆗🆗  SỰ KHÁC BIỆT DỄ HIỂU CỦA FOR VÀ FOR.EACH

    NẾU CẦN THAO TÁC VỚI VỊ TRÍ INDEX THÌ DÙNG VÒNG LẶP FOR, VÌ NÓ LẤY ĐC VỊ TRÍ THỨ I . CÒN CHỈ CẦN DUYỆT QUA DANH SÁCH MẢNG ĐỂ IN RA THÌ DÙNG FOREACH

  🆗🆗🆗🆗🆗


5. Các điểm lưu ý:

  + Kích thước cố định: 
    kíck thước của mảng không thể thay đổi khi đc tạo ra. dùng Arraylist nếu muốn thay đổi kích thước, hoặc tạo 1 mảng ảo có kích thước lớn hơn r gán lại cho mảng cũ

    Vd:
     🆗🆗   THÊM PHẦN TỬ VÀO MẢNG
         // Mảng ban đầu
        int[] oldArray = {1, 2, 3};

        // Tạo mảng mới lớn hơn 1 đơn vị
        int[] newArray = new int[oldArray.length + 1];

        // Sao chép dữ liệu từ mảng cũ sang mảng mới
        for (int i = 0; i < oldArray.length; i++) {
            newArray[i] = oldArray[i];
        }

        // Gán phần tử mới vào cuối mảng
        newArray[newArray.length - 1] = 99;

        // In mảng mới
        for (int num : newArray) {
            System.out.print(num + " ");


    + giá trị mặc định khi khởi tạo nhưng không gán giá trị:
            - int : 0
            - String: null
            - object: null
            - boolean: false
            - double: 0.0

    🆗🆗 THÊM PHẦN TỬ VÀO VỊ TRÍ BẤT KÌ:
    int [] oldArr = {1,2,3};
    int newElement = 99;
    int position = 1; // vị trí muốn thêm vào

    int [] newArr = new int[oldArr.length + 1];
    for (int i = 0; i < position; i++){
     //✅ Sao chép phần tử từ oldArr sang newArr trước vị trí chèn
        newArr[i] = oldArr[i];
    }
    newArr[position] = newElement;

    // ✅ Chép các phần tử còn lại sau vị trí vừa chèn
    for(int i = position; i < oldArr.length -1; i++){
        newArr[i+1]  = oldArr[i];  // Dịch sang phải 1 vị trí trong newArr để tráh bị ghi đề giá trị khi thêm
    }
    

    🆗🆗 XÓA PHẦN TỬ Ở VỊ TRÍ BẤT KÌ:

    int [] oldArr = {1,2,3};
    int deleteIndex = 2;

    int [] newArr = new Int[oldArr.length -1]; //vì xóa sẽ giảm đi 1 phần tử
    for ( int = 0, j = 0; i < oldArr.length, i++){
        if (i != deleteIndex){
            newArr[j++] = oldArr[i];
        }
    }

🔴🔴🔴CÁCH TỐI ƯU NHẤT LÀ DÙNG ARRAYLIST🔴🔴🔴

  🧩 Ví dụ: Thêm và Xóa phần tử với ArrayList  

import java.util.ArrayList;
    // Khởi tạo ArrayList và thêm dữ liệu ban đầu
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);

        System.out.println("Ban đầu: " + numbers);  // [1, 2, 3]

        // 🟢 Thêm phần tử vào vị trí bất kỳ
        numbers.add(1, 99); // Thêm 99 vào vị trí index = 1
        System.out.println("Sau khi thêm 99 vào vị trí 1: " + numbers); // [1, 99, 2, 3]

        // 🔴 Xóa phần tử tại vị trí bất kỳ
        numbers.remove(2); // Xóa phần tử tại index = 2 (là số 2)
        System.out.println("Sau khi xóa phần tử ở vị trí 2: " + numbers); // [1, 99, 3]

        // ✅ Xóa phần tử theo giá trị
        numbers.remove(Integer.valueOf(99)); // Xóa phần tử có giá trị 99
        System.out.println("Sau khi xóa giá trị 99: " + numbers); // [1, 3]

  
  🎯 Ghi nhớ cú pháp ArrayList hữu ích:
    Mục đích	                         Câu lệnh

    Thêm vào cuối	                list.add(element)
    Thêm vào vị trí bất kỳ	        list.add(index, element)
    Xóa theo vị trí             	list.remove(index)
    Xóa theo giá trị	        list.remove(Integer.valueOf(giá_trị))
    Lấy phần tử	                    list.get(index)
    Thay đổi phần tử	            list.set(index, newValue)



6. 🧱 Tư duy giải thuật (algorithmic thinking)

    Đặt câu hỏi:

    Đầu vào là gì?

    Mục tiêu (đầu ra) là gì?

    Cần duyệt qua bao nhiêu lần?

    Cần lưu trạng thái gì (biến đếm, tổng, max...)?

7. 🧰 Sử dụng Arrays trong Java (thư viện hỗ trợ):

import java.util.Arrays; 

int[] arr = {5, 3, 8, 1};
Arrays.sort(arr); // sắp xếp tăng dần
System.out.println(Arrays.toString(arr));  //1,3,5,8

note: khi KHÔNG chuyển sang string để in ra thì giá trị in ra chỉ là chuỗi hascode của object arr
    System.out.println(arr); // [I@1a2b3c4  
    [I nghĩa là "mảng các số nguyên (int[])".
    @1a2b3c4 là hashcode của object arr trong bộ nhớ 



🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
=======CÁC THUẬT TOÁN THƯỜNG GẶP TRONG MẢNG ========

✅1. TÌM SỐ LỚN NHẤT
int[] numbers = {4,2,5,1,6,3}; 
 int max = numnbers[0]; lấy vị trí đầu tiên để so sánh luôn
 for (int i = 1; i < numbers.length; i++){
    if(numbers[i] > max){
        max = numbers[i];
    }
 }


✅🔹 2. Tính tổng các phần tử trong mảng

 int[] ar = {1, 2, 3, 4, 5}; // Khai báo mảng số nguyên
        int sum = 0; // Biến lưu tổng

        for (int i = 0; i < ar.length; i++) {
            sum += ar[i]; // Cộng từng phần tử vào tổng
        }

✅🔹 3. Tìm số lượng số chẵn trong mảng
    int[] ar = {1, 4, 7, 10, 15}; // Mảng đầu vào
        int count = 0; // Đếm số chẵn

        for (int i = 0; i < ar.length; i++) {
            if (ar[i] % 2 == 0) {
                count++; // Nếu chia hết cho 2 thì là số chẵn
            }
        }   

✅🔹 4. Đảo ngược mảng (reverse array)

     int[] ar = {1, 2, 3, 4, 5}; // Mảng ban đầu
        int n = ar.length;

        // Đảo mảng bằng cách đổi chỗ phần tử đầu và cuối
        for (int i = 0; i < n / 2; i++) {
            int temp = ar[i];                 // Lưu tạm phần tử ở vị trí i vào biến temp
            ar[i] = ar[n - 1 - i];            // Gán phần tử từ cuối mảng (vị trí n-1-i) vào vị trí i
            ar[n - 1 - i] = temp;             // Gán lại phần tử temp (ban đầu ở vị trí i) vào vị trí cuối

        }

        // In mảng sau khi đảo
        for (int num : ar) {
            System.out.print(num + " ");
        }


✅🔹 5. Tìm kiếm tuyến tính (Linear Search)
        Duyệt qua từng phần tử từ đầu đến cuối
        Dễ viết, nhưng chậm với mảng lớn

          int[] ar = {10, 20, 30, 40, 50};
        int key = 30; // Giá trị cần tìm

        for (int i = 0; i < ar.length; i++){
            if (ar[i] == key){
            System.out.print("Tìm thấy key tại vị trí" + i);
            break;
            } else {
            System.out.print("Không tìm thấy giá trị");
            }
        }


    📌📌📌THUẬT TOÁN TÌM KIẾM TUYẾN TÍNH📌📌📌

        int [] numbers = {1,2,3,4,5,6,7,8,9,10};
        //tìm số 10. khi đó sẽ trả về vị trí, tạo biến index để lưu vị trí đó
      int index =  linearSearch(numbers,5); //gọi hàm tìm kiếm
        System.out.println("Vị trí index: "+index);
    }
    //THUẬT TOOÁN TÌM KIẾM TUYẾN TÍNH
    public static int linearSearch (int[] arr, int searchValue){
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == searchValue){
                //trả về vị trí tìm được
                return i;
            }
        }
        //kết thúc mà không có giá trị trả về
        return -1;



👉 Tìm kiếm nhị phân (Binary Search):

         Yêu cầu mảng đã sắp xếp
        So sánh với phần tử ở giữa → chia đôi vùng tìm → tiếp tục
        Rất nhanh (độ phức tạp O(log n))

   
  📌📌📌THUẬT TOÁN TÌM KIẾM NHỊ PHÂN binary 📌📌📌

     int [] numbers = {1,2,3,4,5,6,7,8,9,10}; YÊU CẦU MẢNG ĐÃ ĐC SẮP XẾP

    int index=  binarySearch(numbers, 4); //GỌI HÀM ĐỂ TÌM VÀ TẠO BIẾN INDEX LƯU GIÁ TRỊ TÌM ĐC
        System.out.println("index: " + index);
    }

    public static int binarySearch(int[] arr,int searchValue){
        int left = 0;
        int right = arr.length-1;
        while(left<=right){
            int mid = (left+right)/2;
            if(arr[mid]==searchValue){
                return mid;
            }else if(arr[mid]>searchValue){
                right = mid-1; //cập nhật lại biến right 
            }else{
                left = mid+1;
            }
        }
        return -1;

🧠 Giải thích đơn giản lại:
    while (left <= right) {
        int mid = (left + right) / 2;
    Bạn lấy phần tử giữa mảng (mid).

    So sánh arr[mid] với searchValue (giá trị cần tìm):

    ✅ Trường hợp 1: arr[mid] == searchValue
    👉 Đã tìm thấy → return mid.

    ✅ Trường hợp 2: arr[mid] > searchValue
    👉 Giá trị cần tìm nhỏ hơn, nên nó phải nằm bên trái.
    👉 Cập nhật right = mid - 1 để thu hẹp về bên trái.

    ✅ Trường hợp 3: arr[mid] < searchValue
    👉 Giá trị cần tìm lớn hơn, nên nó phải nằm bên phải.
    👉 Cập nhật left = mid + 1 để thu hẹp về bên phải.

    ✅ Kết luận:
    Điều kiện while (left <= right) đảm bảo vòng lặp tiếp tục khi còn phạm vi để tìm.

    Cách cập nhật left và right giúp ta chia đôi mảng mỗi lần, tìm kiếm cực nhanh.



🧠🧠🧠🧠🧠Tóm gọn cho 2 phương thức tìm kiếm binary và linear

  👉  Tìm tất cả các giá trị giống nhau → dùng Linear Search (tuyến tính).

  👉  Tìm một giá trị đầu tiên tìm thấy (trong mảng đã sắp xếp) → dùng Binary Search (nhị phân, chia để trị, nhanh hơn).

📝 Ghi nhớ thêm:

    Linear Search: đơn giản, không cần mảng sắp xếp.

    Binary Search: nhanh, nhưng phải sắp xếp mảng trước.



✅🔹 6. Sắp xếp theo thứ tự tăng dần bằng hàm có sẵn của Java là Arrays.sort()
    import java.util.Arrays;

          int[] numbers = {5, 2, 9, 1, 3};

        // Sắp xếp mảng tăng dần
        Arrays.sort(numbers);

        // In mảng sau khi sắp xếp
        System.out.println("Mảng sau khi sắp xếp:");
        for (int num : numbers) {
            System.out.print(num + " ");
        }

        🗂 Áp dụng với mảng khác:
    🔤 Mảng chuỗi:
    String[] names = {"Nam", "An", "Bình", "Hà"};
    Arrays.sort(names); // Sắp xếp theo thứ tự bảng chữ cái

    🔢 Mảng số thực:
    double[] prices = {19.9, 5.5, 12.0};
    Arrays.sort(prices); // Kết quả: 5.5, 12.0, 19.9



✅🔹 7. Sắp xếp mảng tăng dần (Bubble Sort đơn giản)
    int[] arr = {5, 3, 8, 1, 2};

        // Sắp xếp bằng thuật toán nổi bọt (bubble sort)
        for (int i = 1; i < arr.length; i++) {
            for (int j = 0; j < arr.length - i; j++) {
                if (arr[j] > arr[j + 1]) {
         // Đổi chỗ nếu phần tử trước lớn hơn phần tử sau
                int temp = arr[j];        // Lưu tạm phần tử trước (vị trí j)
                arr[j] = arr[j + 1];       // Gán phần tử sau (vị trí j+1) vào vị trí j
                arr[j + 1] = temp;        // Gán lại giá trị tạm vào vị trí j+1 → hoàn tất hoán đổi
                }
            }
        }

        // In mảng sau khi sắp xếp
        for (int num : ar) {
            System.out.print(num + " ");
        }




✅🔹 8. XẾP TRỰC TIẾP BẰNG Selection Sort (Sắp xếp chọn trực tiếp)
        
        int[] ar = {5, 3, 1};
        int n = ar.length;

        for (int i = 0; i < n - 1; i++) {
            int minIndex = i; // Giả sử phần tử i là nhỏ nhất

            // Tìm vị trí phần tử nhỏ nhất từ i+1 đến cuối
            for (int j = i + 1; j < n; j++) {
                if (ar[j] < ar[minIndex]) {
                    minIndex = j; // Cập nhật vị trí phần tử nhỏ nhất
                }
            }

            // Đổi chỗ phần tử nhỏ nhất với phần tử ở vị trí i
            int temp = ar[i];
            ar[i] = ar[minIndex];
            ar[minIndex] = temp;
        }
        

✅🔹 9 sắp xếp chèn Insertion Sort


 int[] arr = {5, 3, 1, 4, 2};  // Mảng ban đầu chưa sắp xếp

        // Duyệt qua từng phần tử từ vị trí thứ 1 (vì phần tử đầu tiên đã "được coi là sắp xếp")
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];     // Lưu giá trị hiện tại cần chèn
            int j = i - 1;

            // Dịch các phần tử lớn hơn key sang phải
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];  // Dịch phần tử sang phải
                j--;                  // Lùi về để so sánh tiếp
            }

            // Chèn key vào đúng vị trí đã tìm được
            arr[j + 1] = key;
        }

        // In kết quả
  System.out.println("Mảng sau khi sắp xếp (Insertion Sort): " + Arrays.toString(arr));



🧰🧰🧰🧰🧰🧰🧰🧰🧰🧰🧰🧰🧰🧰🧰🧰

 MẢNG & THUẬT TOÁN JAVA
│
├── 1. Khái niệm mảng
│   ├── Mảng 1 chiều
│   └── Mảng 2 chiều
│
├── 2. Khai báo & khởi tạo
│   ├── new int[5]
│   └── int[] arr = {1, 2, 3}
│
├── 3. Truy cập phần tử
│   ├── arr[0] = 10
│   └── System.out.println(arr[i])
│
├── 4. Duyệt mảng
│   ├── Vòng lặp for
│   └── Vòng lặp for-each
│
├── 5. Thuật toán cơ bản
│   ├── Tìm max / min
│   ├── Tính tổng / trung bình
│   ├── Đếm phần tử thỏa mãn
│   ├── Tìm kiếm
│   │   ├── Tuyến tính (Linear search)
│   │   └── Nhị phân (Binary search)
│   └── Sắp xếp
│       ├── Bubble Sort
│       └── Selection Sort
│
├── 6. Thư viện Arrays
│   ├── Arrays.sort(arr)
│   ├── Arrays.toString(arr)
│   └── Arrays.copyOf(arr, newLength)
│
└── 7. Tư duy giải thuật
    ├── Xác định đầu vào / đầu ra
    ├── Duyệt mảng bao nhiêu lần?
    ├── Biến lưu trạng thái (tổng, đếm, max...)
    └── Viết giả mã (pseudo-code) trước khi code


    🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
    MẢNG 2 CHIỀU HOẶC ĐA CHIỀU

✅1. Mảng 2 chiều
 int [][] arr;
 int [][] arr = new int[3][4]; // 3 hàng 4 cột
 int [][] arr = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}; //khai báo và gán giá trị

 🔁DUYỆT MẢNG 2 CHIỀU (for lồng nhau)

    for (int i = 0; i < arr.length; i++) {             // duyệt từng hàng
        for (int j = 0; j < arr[i].length; j++) {      // duyệt từng cột
            System.out.print(arr[i][j] + " ");
        }
        System.out.println();  // xuống dòng sau mỗi hàng
    }

 🧠  HOẶC DÙNG FOR-EACH:

    for (int[] row : arr) {
        for (int value : row) {
            System.out.println(value);
        }
    }


✅2. Mảng 3 chiều
int [][][] arr;
int [][][] arr = {
                { {1,2}, {3,4} },
                 { {5,6},{7,8} }
                };
        int value = arr[1][0][1];
// cập phần tử tại lớp thứ 2, dòng thứ 1, cột thứ 2 kết quả: 6

     🔁DUYỆT MẢNG 3 CHIỀU (for lồng nhau)

for (int i = 0; i < arr.length; i++) {               // duyệt khối
    for (int j = 0; j < arr[i].length; j++) {        // duyệt hàng trong khối
        for (int k = 0; k < arr[i][j].length; k++) { // duyệt cột trong hàng
            System.out.println("arr[" + i + "][" + j + "][" + k + "] = " + arr[i][j][k]);
        }
    }
}

🧠  HOẶC DÙNG FOR-EACH:

 for (int[][] block : arr) {             // Duyệt qua từng khối
    for (int[] row : block) {           // Duyệt từng hàng trong khối
        for (int value : row) {         // Duyệt từng phần tử trong hàng
            System.out.print(value + " ");
        }
        System.out.println(); // Xuống dòng sau mỗi hàng
    }
    System.out.println("-----"); // Phân cách giữa các khối
}


☑️ for-each giúp mã ngắn gọn và dễ đọc hơn, nhưng bạn không lấy được chỉ số index trong từng cấp.

LƯU Ý: arr.length là số HÀNG
        arr[i].length là số CỘT của hàng thứ i



✅. MẢNG KHÔNG ĐỀU JAGGED ARRAY
 
    int[][] jagged = new int[3][];  // Khởi tạo mảng 2 chiều có 3 hàng (chưa gán cột)

    jagged[0] = new int[2];         // Hàng 0 có 2 cột
    jagged[1] = new int[3];         // Hàng 1 có 3 cột
    jagged[2] = new int[1];         // Hàng 2 có 1 cột

    📥 Ví dụ gán và in giá trị:

    int count = 1;
        for (int i = 0; i < jagged.length; i++) {
            for (int j = 0; j < jagged[i].length; j++) {
                jagged[i][j] = count++;
            }
        }

    // In mảng
        for (int[] row : jagged) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }

    .

📥 1. Sử dụng mảng không đều Khi các hàng có số lượng phần tử khác nhau
Ví dụ:

    Học sinh	Số môn học
    A	            3 môn
    B	            5 môn
    C           	2 môn

int[][] diem = new int[3][];
diem[0] = new int[3]; // Học sinh A học 3 môn
diem[1] = new int[5]; // Học sinh B học 5 môn
diem[2] = new int[2]; // Học sinh C học 2 môn
📌 Không thể dùng int[3][5] (mảng đều) vì sẽ lãng phí bộ nhớ cho các ô không dùng.

📥2. Khi xử lý dữ liệu không đồng nhất
Ví dụ: lưu số lượng bài viết mỗi ngày trên 1 tuần, nhưng mỗi ngày lại có số bài khác nhau.
    String[][] baiViet = new String[7][];
    baiViet[0] = new String[] {"A", "B"};     // Thứ 2 có 2 bài
    baiViet[1] = new String[] {"C"};          // Thứ 3 có 1 bài
    baiViet[2] = new String[] {"D", "E", "F"}; // Thứ 4 có 3 bài
    // ...


📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥

📥📥📥📥📥📥📥 //// BÀI TOÁN TỔNG HỢP ///📥📥📥📥📥📥

📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥📥

import java.util.Scanner;

    public static void main(String[] args) {

//        Nhập điểm cho N học sinh
//        Tìm điểm cao nhất, thấp nhất
//        Tìm kiếm xem có học sinh nào đạt điểm X không
//        Sắp xếp điểm theo thứ tự tăng dần

        int[] diem = new int[100];
        Scanner sc = new Scanner(System.in);
        System.out.println("Nhập số học sinh");
        int students = sc.nextInt();
        for (int i = 0; i < students; i++) {
            //nhập điểm cho từng học sinh
            System.out.println("Nhập Điểm: ");
            diem[i] = sc.nextInt();
        }
    }

    // hàm tìm điểm cao nhất

    public static int findMax(int[] max, int diemValue) {
        int maxValue = max[0];
        for (int i = 1; i < diemValue; i++) {
            if (max[i] > maxValue) {
                maxValue = max[i];
            }
        }
        return maxValue;
    }

    //hàm tìm kiếm học sinh nào đạt điểm X

    public static int finddiemX(int[] diem, int diemX) {
        for (int i = 1; i < diem.length; i++) {
            if (diem[i] == diemX) {
                return i;
            }
        }
        return -1;
    }

    //hàm Sắp xếp điểm theo thứ tự tăng dần/giảm dần
     public static void selectionSort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            int maxIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (array[j] > array[maxIndex]) {
                    maxIndex = j;
                }
            }
            // Hoán đổi phần tử lớn nhất với phần tử đầu tiên chưa được sắp xếp
            int temp = array[maxIndex];
            array[maxIndex] = array[i];
            array[i] = temp;
    }

    🔍 Từng bước diễn giải dễ hiểu:
    Giả định rằng phần tử ở vị trí i là lớn nhất trong đoạn chưa sắp xếp.
    maxValue = i;
    Dò tìm trong các phần tử từ i + 1 đến hết mảng:
    So sánh từng phần tử arr[j] với arr[maxValue].
    Nếu arr[j] lớn hơn, cập nhật maxValue = j.
    Sau vòng lặp trong:
    Bạn đã biết vị trí maxValue là phần tử lớn nhất trong phần chưa sắp xếp.
    Hoán đổi phần tử này với arr[i] để đưa phần tử lớn nhất về đúng chỗ (đầu đoạn chưa sắp xếp).
    Tiếp tục vòng i++ để xử lý đoạn tiếp theo.

}
